<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Gauss Magnetismo: Resumen con Color</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#20c997; /* Color de acento (verde azulado) */
      --muted:#9aa6b2;
      --card:#0b1220;
      --tooltip-bg: rgba(0, 0, 0, 0.95);
    }
    body{
      margin:0;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background:linear-gradient(180deg,#071022 0%, #081428 100%);
      color:#e6eef6;
    }
    .container{
      display:grid;
      grid-template-columns:330px 1fr;
      gap:10px;
      padding:10px;
      height:100vh;
      box-sizing:border-box;
    }
    .panel{
      background:var(--card);
      border-radius:10px;
      padding:12px;
      box-shadow:0 6px 18px rgba(2,6,23,0.6);
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow: visible;
    }
    h2{margin:0 0 4px;font-size:18px;}
    label{font-size:13px;color:var(--muted);display:block;margin:4px 0;}
    input[type=range]{width:100%; cursor: pointer;}
    canvas{
      width:100%;
      height:100%;
      border-radius:8px;
      display:block;
      cursor: crosshair;
    }
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
    .btn{
      padding:6px 10px;
      border-radius:8px;
      background:transparent;
      border:1px solid rgba(255,255,255,0.08);
      color:#fff;
      cursor:pointer;
      font-size:13px;
      transition: background 0.2s;
    }
    .btn:hover { background: rgba(255,255,255,0.05); }
    .small{font-size:12px;color:var(--muted);}
    .legend span{display:block;font-size:12px;color:var(--muted);}

    /* Tooltips & Info Box */
    [data-tooltip] { position: relative; cursor: help; }
    [data-tooltip]::after {
      content: attr(data-tooltip); position: absolute; bottom: 120%; left: 50%;
      transform: translateX(-50%) translateY(10px); background: var(--tooltip-bg); color: #fff;
      padding: 8px 12px; border-radius: 6px; font-size: 12px; width: max-content; max-width: 220px;
      text-align: center; opacity: 0; visibility: hidden; transition: all 0.2s; pointer-events: none; z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.1);
    }
    [data-tooltip]:hover::after { opacity: 1; visibility: visible; transform: translateX(-50%) translateY(0); }

    .info-box {
      background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05);
      border-radius: 8px; padding: 10px; margin-top: auto;
    }
    .equation {
      font-family: 'Times New Roman', serif; font-style: italic; font-size: 16px;
      text-align: center; margin-bottom: 8px; color: #fff; letter-spacing: 1px;
    }
    .conclusions { margin: 0; padding-left: 18px; color: var(--muted); font-size: 11.5px; line-height: 1.4; }
    .conclusions li { margin-bottom: 4px; }
    
    /* NUEVA REGLA: Clase para resaltar con color y semi-negrita */
    .conclusions .highlight { 
        color: var(--accent); 
        font-weight: 600; 
    }

    .gradient-legend {
      height: 6px; width: 100%; border-radius: 3px; margin-top: 4px; opacity: 0.9;
      background: linear-gradient(90deg, hsl(240,100%,50%) 0%, hsl(180,100%,50%) 33%, hsl(60,100%,50%) 66%, hsl(0,100%,60%) 100%);
    }
    .gradient-labels { display: flex; justify-content: space-between; font-size: 10px; color: var(--muted); margin-top:2px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="panel">
      <div>
        <h2>Ley de Gauss (Magnetismo)</h2>
        <div class="small">El flujo magn√©tico total a trav√©s de cualquier superficie cerrada es cero.</div>
      </div>
      
      <hr>

      <div>
        <label><strong>Simulaci√≥n</strong></label>
        <div class="row">
          <button id="play"  class="btn" data-tooltip="Reanuda el movimiento de las part√≠culas.">Iniciar</button>
          <button id="pause" class="btn" data-tooltip="Congela el movimiento.">Pausar</button>
          <button id="reset" class="btn" data-tooltip="Reinicia posici√≥n y par√°metros.">Reset</button>
        </div>
      </div>

      <div>
        <label><strong>Opciones visuales</strong></label>
        <div data-tooltip="Flechas que muestran la intensidad (color) y direcci√≥n local del campo magn√©tico.">
          <label><input id="show-vectors" type="checkbox" checked> Mostrar vectores (Heatmap)</label>
          <div class="gradient-legend"></div>
          <div class="gradient-labels"><span>D√©bil</span><span>Intenso</span></div>
        </div>
        <div data-tooltip="Part√≠culas viajando sobre las l√≠neas de campo para visualizar el flujo.">
          <label><input id="show-stream" type="checkbox" checked> Mostrar flujo (part√≠culas)</label>
        </div>
      </div>
      
      <hr>

      <div>
        <label><strong>Par√°metros del Dipolo</strong></label>
        <label data-tooltip="Ajusta la intensidad de las corrientes en los lazos.">Corriente (|I|): <input id="paramI" type="range" min="0.5" max="5" step="0.1" value="2"></label>
        <label data-tooltip="Cambia la separaci√≥n entre los dos lazos de corriente.">Distancia (L): <input id="paramL" type="range" min="40" max="220" step="5" value="120"></label>
        <label data-tooltip="Modifica el radio de cada lazo de corriente.">Radio (a): <input id="paramR" type="range" min="25" max="120" step="5" value="60"></label>
      </div>

      <div class="legend">
        <span>‚äô Corriente Saliente (Polo Norte)</span>
        <span>‚äó Corriente Entrante (Polo Sur)</span>
        <span>üîµ Superficie Gaussiana (Imaginaria)</span>
      </div>

      <div class="info-box">
        <div class="equation" data-tooltip="La Ley de Gauss para el Magnetismo establece que el flujo magn√©tico neto a trav√©s de cualquier superficie cerrada (como la esfera azul punteada) es siempre cero.">‚àÆ B ¬∑ dA = 0</div>
        <ul class="conclusions">
          <li>Esto significa que <span class="highlight">no existen los monopolos magn√©ticos aislados</span>.</li>
          <li>Las l√≠neas de campo magn√©tico <span class="highlight">siempre forman lazos cerrados</span>, entrando por un "polo" y saliendo por el otro.</li>
          <li>Cualquier campo magn√©tico que entra en una superficie cerrada, <span class="highlight">siempre sale</span> por otra parte de la misma superficie.</li>
        </ul>
      </div>
    </div>

    <div class="panel">
      <canvas id="simCanvas"></canvas>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('simCanvas');
    const ctx     = canvas.getContext('2d');
    const DPR     = window.devicePixelRatio || 1;
    
    const fixedSpeed = 1.0; 

    // Estado
    const dipole = { cx: 0, cy: 0, L:120, r:60, I:2 };
    const particles = [];
    let isPlaying = true;
    let mousePos = { x: 0, y: 0, onCanvas: false };

    function resize(){
      canvas.width  = canvas.clientWidth * DPR;
      canvas.height = canvas.clientHeight * DPR;
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    
    dipole.cx = canvas.clientWidth/2;
    dipole.cy = canvas.clientHeight/2;
    resize(); 
    window.addEventListener('resize', resize);

    // Controles
    document.getElementById('play').onclick  = ()=> isPlaying = true;
    document.getElementById('pause').onclick = ()=> isPlaying = false;
    document.getElementById('reset').onclick = ()=>{
      dipole.cx = canvas.clientWidth/2; dipole.cy = canvas.clientHeight/2;
      dipole.L=120; dipole.r=60; dipole.I=2;
      document.getElementById('paramL').value = 120;
      document.getElementById('paramR').value = 60;
      document.getElementById('paramI').value = 2;
      particles.length = 0; spawnParticles(220);
    };
    
    ['paramI', 'paramL', 'paramR'].forEach(id => {
        document.getElementById(id).addEventListener('input', ()=>{
        });
    });

    function spawnParticles(n=160){
      for(let i=0;i<n;i++){
        particles.push({x:Math.random()*canvas.clientWidth, y:Math.random()*canvas.clientHeight, age:Math.random()*200});
      }
    }
    spawnParticles(220);

    let draggingDipole = false, dragOffX=0, dragOffY=0;
    canvas.addEventListener('mousedown', e=>{
      const x = mousePos.x, y = mousePos.y;
      const {xL,yL,xR,yR} = loopCenters();
      if(Math.hypot(x-xL,y-yL)<=dipole.r*1.1 || Math.hypot(x-xR,y-yR)<=dipole.r*1.1){
        draggingDipole=true; dragOffX=x-dipole.cx; dragOffY=y-dipole.cy; canvas.style.cursor='grabbing';
      }
    });
    canvas.addEventListener('mouseenter', ()=>mousePos.onCanvas=true);
    canvas.addEventListener('mouseleave', ()=>{mousePos.onCanvas=false; draggingDipole=false; canvas.style.cursor='crosshair';});
    canvas.addEventListener('mousemove', e=>{
      const r = canvas.getBoundingClientRect();
      mousePos.x = e.clientX-r.left; mousePos.y = e.clientY-r.top;
      if(draggingDipole){ 
          dipole.cx=mousePos.x-dragOffX; dipole.cy=mousePos.y-dragOffY; 
      }
    });
    window.addEventListener('mouseup', ()=>{draggingDipole=false; canvas.style.cursor='crosshair';});

    function loopCenters(){
      return { xL: dipole.cx-dipole.L/2, yL: dipole.cy, xR: dipole.cx+dipole.L/2, yR: dipole.cy };
    }

    function Bz_from_loop(x,y, x0,y0, I, a){
      const r = Math.hypot(x-x0,y-y0);
      const dist = Math.max(r, 1); 
      return 220 * I * (a*a) / Math.pow(dist*dist + a*a, 1.5);
    }
    function Bz_at(x,y){
      const {xL,yL,xR,yR} = loopCenters();
      return Bz_from_loop(x,y,xL,yL,dipole.I,dipole.r) + Bz_from_loop(x,y,xR,yR,-dipole.I,dipole.r);
    }
    function B_vec_in_plane(x,y){
      const h = 4;
      const Bx = -(Bz_at(x+h,y)-Bz_at(x-h,y))/(2*h);
      const By = -(Bz_at(x,y+h)-Bz_at(x,y-h))/(2*h);
      return { x: Bx, y: By };
    }

    function drawSophisticatedArrow(ctx, x, y, vx, vy) {
      const mag = Math.hypot(vx, vy);
      if (mag < 0.001) return;
      const angle = Math.atan2(vy, vx);
      const intensity = Math.min(1, Math.log(mag * 4 + 1) / 3.5); 
      const hue = (1 - intensity) * 240; 
      const lightness = 50 + intensity * 15;
      const alpha = 0.4 + intensity * 0.6;
      const color = `hsla(${hue}, 100%, ${lightness}%, ${alpha})`;
      const len = 12 + intensity * 18; 
      
      ctx.save();
      ctx.translate(x, y); ctx.rotate(angle);
      ctx.beginPath(); 
      ctx.moveTo(-len/2, 0); ctx.lineTo(len/2, 0); 
      
      const headSize = 5 + intensity * 3;
      ctx.lineTo(len/2 - headSize, -headSize * 0.6); 
      ctx.moveTo(len/2, 0); 
      ctx.lineTo(len/2 - headSize, headSize * 0.6);
      
      ctx.strokeStyle = color; ctx.lineWidth = 1.5 + intensity * 2;
      ctx.lineCap = 'round'; ctx.lineJoin = 'round';
      ctx.stroke();
      
      ctx.restore();
    }
    
    function calculateFlux() {
        const N_samples = 720; 
        const Rg = Math.max(dipole.L, 2 * dipole.r) * 0.8;
        const cx = dipole.cx, cy = dipole.cy;
        const dA = (2 * Math.PI * Rg) / N_samples;
        
        let totalFlux = 0;
        let fluxIn = 0;
        let fluxOut = 0;

        for (let i = 0; i < N_samples; i++) {
            const angle = 2 * Math.PI * i / N_samples;
            const sx = cx + Rg * Math.cos(angle);
            const sy = cy + Rg * Math.sin(angle);

            const B_vec = B_vec_in_plane(sx, sy);
            const nx = Math.cos(angle); 
            const ny = Math.sin(angle);
            
            const B_dot_n = B_vec.x * nx + B_vec.y * ny;

            const dFlux = B_dot_n * dA;
            totalFlux += dFlux;

            if (dFlux > 0) {
                fluxOut += dFlux; 
            } else {
                fluxIn += dFlux; 
            }
        }
        
        const numericalError = 1e-4; 
        if (Math.abs(totalFlux) < numericalError) {
             totalFlux = 0;
        }

        return { totalFlux: totalFlux, fluxIn: fluxIn, fluxOut: fluxOut, Rg: Rg, N_samples: N_samples };
    }


    function draw() {
      const W = canvas.clientWidth; 
      const H = canvas.clientHeight;
      
      ctx.clearRect(0,0,W,H); 
      ctx.fillStyle = '#050814'; 
      ctx.fillRect(0,0,W,H);

      // Dibujar la rejilla de fondo
      ctx.strokeStyle = '#1f2937'; ctx.lineWidth=1; ctx.beginPath();
      for(let x=0;x<W;x+=40){ctx.moveTo(x,0);ctx.lineTo(x,H);}
      for(let y=0;y<H;y+=40){ctx.moveTo(0,y);ctx.lineTo(W,y);}
      ctx.stroke();

      const speed = fixedSpeed; 
      
      dipole.I = parseFloat(document.getElementById('paramI').value);
      dipole.L = parseFloat(document.getElementById('paramL').value);
      dipole.r = parseFloat(document.getElementById('paramR').value);
      const {xL,yL,xR,yR} = loopCenters();
      
      // --- C√ÅLCULO DE FLUJO ---
      const fluxData = calculateFlux();
      const phiB = fluxData.totalFlux.toFixed(4);
      const phiIn = Math.abs(fluxData.fluxIn).toFixed(2);
      const phiOut = fluxData.fluxOut.toFixed(2);
      
      // --- RENDERIZADO DE DATOS EN CANVAS (SUPERIOR DERECHA) ---
      const dataBoxW = 200;
      const dataBoxH = 80;
      const dataBoxX = W - dataBoxW - 10; 
      const dataBoxY = 10;
      
      // Fondo de la caja de datos
      ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.fillRect(dataBoxX, dataBoxY, dataBoxW, dataBoxH);
      
      ctx.textAlign = 'right';
      let currentY = dataBoxY + 15;
      
      // T√≠tulo
      ctx.fillStyle = '#fff';
      ctx.font = '14px sans-serif';
      ctx.fillText('DATOS DE FLUJO (Œ¶)', dataBoxX + dataBoxW - 5, currentY);
      currentY += 20;

      // Œ¶_B Neto
      ctx.fillStyle = '#20c997'; 
      ctx.font = 'bold 16px monospace';
      ctx.textAlign = 'left';
      ctx.fillText('Œ¶B Neto:', dataBoxX + 5, currentY);
      ctx.textAlign = 'right';
      ctx.fillText(phiB, dataBoxX + dataBoxW - 5, currentY);
      currentY += 20;

      // Œ¶_out (Salida)
      ctx.fillStyle = '#fef08a'; 
      ctx.font = '14px monospace';
      ctx.textAlign = 'left';
      ctx.fillText('Salida (Œ¶out):', dataBoxX + 5, currentY);
      ctx.textAlign = 'right';
      ctx.fillText(phiOut, dataBoxX + dataBoxW - 5, currentY);
      currentY += 20;

      // Œ¶_in (Entrada)
      ctx.fillStyle = '#7dd3fc'; 
      ctx.textAlign = 'left';
      ctx.fillText('Entrada (Œ¶in):', dataBoxX + 5, currentY);
      ctx.textAlign = 'right';
      ctx.fillText(phiIn, dataBoxX + dataBoxW - 5, currentY);
      
      // Restablecer alineaci√≥n
      ctx.textAlign = 'left';

      // Lazos
      ctx.lineWidth=2;
      ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.beginPath(); ctx.arc(xL,yL,dipole.r,0,Math.PI*2); ctx.stroke();
      ctx.fillStyle='rgba(255,255,140,0.9)'; ctx.beginPath(); ctx.arc(xL,yL,10,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#000'; ctx.font='12px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('‚äô',xL,yL);
      ctx.beginPath(); ctx.arc(xR,yR,dipole.r,0,Math.PI*2); ctx.stroke();
      ctx.fillStyle='rgba(120,255,220,0.9)'; ctx.beginPath(); ctx.arc(xR,yR,10,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#000'; ctx.fillText('‚äó',xR,yR);


      // Vectores
      if(document.getElementById('show-vectors').checked){
        const step = 35;
        for(let gx=20; gx<W; gx+=step){
          for(let gy=20; gy<H; gy+=step){
            const v = B_vec_in_plane(gx,gy);
            drawSophisticatedArrow(ctx, gx, gy, v.x, v.y);
          }
        }
      }

      // Part√≠culas
      if(document.getElementById('show-stream').checked){
        particles.forEach(p=>{
          const v = B_vec_in_plane(p.x,p.y);
          if(isPlaying){ p.x+=v.x*0.07*speed; p.y+=v.y*0.07*speed; p.age+=speed; }
          if(p.x<0||p.x>W||p.y<0||p.age>500){ p.x=Math.random()*W; p.y=Math.random()*H; p.age=0; }
          const velMag = Math.hypot(v.x, v.y);
          const alpha = Math.min(0.8, velMag * 2 + 0.3);
          ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x-v.x*0.8, p.y-v.y*0.8);
          ctx.strokeStyle=`rgba(255,255,255,${alpha})`; ctx.lineWidth=1; ctx.stroke();
        });
      }

      // Superficie Gaussiana (C√°lculo y Dibujo de Flechas de Flujo)
      const Rg = fluxData.Rg;
      const cx = dipole.cx, cy = dipole.cy;
      
      // Dibujar el contorno
      ctx.setLineDash([6,4]); ctx.strokeStyle='rgba(100,200,255,0.7)'; ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.arc(cx,cy,Rg,0,Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
      
      // Flechas de Flujo Normal
      const N_draw = 24; 
      
      for(let i=0;i<N_draw;i++){
        const angle = 2*Math.PI*i/N_draw; 
        const sx=cx+Rg*Math.cos(angle), sy=cy+Rg*Math.sin(angle);

        const B_vec = B_vec_in_plane(sx, sy);
        const nx = Math.cos(angle); 
        const ny = Math.sin(angle);
        const B_dot_n = B_vec.x * nx + B_vec.y * ny;

        const L_raw = B_dot_n * 10; 
        const L = Math.min(Math.max(L_raw, -25), 25); 

        ctx.save(); ctx.translate(sx,sy); ctx.rotate(Math.atan2(ny,nx));
        
        ctx.beginPath(); 
        
        const L_abs = Math.abs(L);
        const headSize = 4;

        if (L > 0) { // Flujo saliente (Amarillo)
            ctx.strokeStyle = '#fef08a'; ctx.fillStyle = ctx.strokeStyle;
            ctx.moveTo(0, 0); ctx.lineTo(L_abs, 0);
            ctx.lineTo(L_abs - headSize, -headSize); ctx.moveTo(L_abs, 0); ctx.lineTo(L_abs - headSize, headSize);
        } else { // Flujo entrante (Azul)
            ctx.strokeStyle = '#7dd3fc'; ctx.fillStyle = ctx.strokeStyle;
            ctx.moveTo(-L_abs, 0); ctx.lineTo(0, 0);
            ctx.lineTo(-headSize, -headSize); ctx.moveTo(0, 0); ctx.lineTo(-headSize, headSize);
        }

        ctx.lineWidth=2; 
        ctx.stroke(); 
        ctx.fill(); 
        ctx.restore();
      }

      ctx.textAlign='left'; ctx.fillStyle='#fff'; 
      ctx.fillText('Superficie S', cx-Rg, cy-Rg-10);

      if(mousePos.onCanvas && !draggingDipole){
          const v = B_vec_in_plane(mousePos.x, mousePos.y);
          const mag = Math.hypot(v.x, v.y);
          ctx.save(); ctx.translate(mousePos.x+15, mousePos.y+15);
          ctx.fillStyle='rgba(0,0,0,0.85)'; ctx.roundRect(0,0,95,28,4); ctx.fill();
          ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.lineWidth=1; ctx.stroke();
          ctx.fillStyle='#fff'; ctx.font='bold 12px monospace';
          const hue = (1 - Math.min(1, Math.log(mag*4+1)/3.5)) * 240; 
          ctx.fillStyle = `hsl(${hue}, 100%, 60%)`;
          ctx.beginPath(); ctx.arc(10,14,4,0,Math.PI*2); ctx.fill();
          ctx.fillStyle='#fff'; ctx.fillText('|B|: ' + mag.toFixed(2), 20, 14);
          ctx.restore();
      }

      ctx.fillStyle='rgba(255,255,255,0.04)'; ctx.fillRect(10,10,300,40);
      ctx.fillStyle='#fff'; ctx.font='12px sans-serif'; ctx.fillText('Gauss (Magnetismo)',18,25);
      ctx.fillStyle='rgba(255,255,255,0.6)'; ctx.font='11px sans-serif'; ctx.fillText('Visualizaci√≥n de Flujo Neto (Œ¶B)',18,40);
    }

    function loop(){ draw(); requestAnimationFrame(loop); }
    loop();
  </script>
</body>
</html>