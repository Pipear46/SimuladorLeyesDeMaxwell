<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini planta eléctrica — Ley de Faraday-Lenz (simulador)</title>
  <style>
    :root{--bg:#0f1720;--card:#0b1220;--accent:#16a34a;--muted:#94a3b8}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071029 0%, #081426 100%);font-family:Inter,Segoe UI,Helvetica,Arial,sans-serif;color:#dbe7f7}
    .app{max-width:1100px;margin:28px auto;padding:18px}
    header{display:flex;align-items:center;gap:16px}
    h1{font-size:20px;margin:0}
    .layout{display:grid;grid-template-columns:1fr 360px;gap:18px;margin-top:14px}
    .card{background:rgba(255,255,255,0.02);border-radius:10px;padding:12px}
    .sim{height:420px;display:flex;flex-direction:column;gap:10px}
    canvas{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:8px}
    .controls{display:flex;flex-direction:column;gap:10px}
    label{font-size:13px;color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center}
    input[type=range]{width:100%}
    button{background:var(--accent);border:0;padding:8px 10px;border-radius:8px;color:#042014;cursor:pointer}
    .small{font-size:13px;color:#cfe7ff}
    .led{width:28px;height:28px;border-radius:50%;background:#2c3540;box-shadow:inset -2px -2px 6px rgba(0,0,0,0.4)}
    .led.on{background:radial-gradient(circle at 30% 30%, #fff7c9, #ffeb6b 20%, #ffb703 60%);box-shadow:0 0 16px rgba(255,170,0,0.7)}
    .meter{font-weight:700;font-size:20px}
    .footer{font-size:13px;color:var(--muted);margin-top:8px}
    .legend{display:flex;gap:10px;align-items:center}
    .pole{width:18px;height:12px;border-radius:3px;background:#c33}
    .pole.south{background:#2353c8}
    .btn-row{display:flex;gap:8px}
    .canvas-wrap{display:flex;gap:10px}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Mini planta eléctrica — Ley de Faraday y Lenz (simulador)</h1>
      <div class="small">Mueve el imán dentro/fuera de la bobina y observa la tensión inducida y la ley de Lenz.</div>
    </header>

    <div class="layout">
      <div class="card sim">
        <canvas id="scene" width="700" height="280"></canvas>
        <div class="canvas-wrap">
          <canvas id="plot" width="700" height="120"></canvas>
        </div>

        <div class="footer">Modelo simplificado: flujo magnético Φ ≈ N · A · B(z). Se calcula V = -N · dΦ/dt. El simulador usa una B(z) tipo "campana" alrededor del imán para modelar el campo.</div>
      </div>

      <div class="card controls">
        <div class="row btn-row">
          <button id="play">▶ Reproducir</button>
          <button id="pause">⏸ Pausa</button>
          <button id="step">⏭ Un paso</button>
          <button id="reset">↺ Reset</button>
        </div>

        <div>
          <label>Movimiento: <span id="modeLabel">Oscilar</span></label>
          <div class="row">
            <select id="mode">
              <option value="osc">Oscilar (automático)</option>
              <option value="manual">Manual (arrastra imán)</option>
              <option value="sweep">Barrer (atravesar la bobina)</option>
            </select>
          </div>
        </div>

        <div>
          <label>Número de vueltas N: <span id="Nval">200</span></label>
          <input id="N" type="range" min="10" max="2000" value="200">
        </div>

        <div>
          <label>Fuerza del imán (B₀): <span id="Bval">1.0</span></label>
          <input id="B0" type="range" min="0.2" max="3.0" step="0.1" value="1.0">
        </div>

        <div>
          <label>Velocidad / frecuencia: <span id="speedVal">1.0</span></label>
          <input id="speed" type="range" min="0.1" max="5.0" step="0.1" value="1.0">
        </div>

        <div>
          <label>Área de la bobina A (cm²): <span id="Aval">10</span></label>
          <input id="A" type="range" min="1" max="50" value="10">
        </div>

        <div class="row">
          <div>LED:</div>
          <div class="led" id="led"></div>
          <div class="small">(simulado: enciende si |V| &gt; 0.15)</div>
        </div>

        <div class="row">
          <div>Voltímetro (instantáneo):</div>
          <div class="meter" id="voltage">0.00 V</div>
        </div>

        <div>
          <label>Polaridad (muestra dirección de la corriente inducida):</label>
          <div class="row legend"><div class="pole"></div><div class="small">Norte</div><div class="pole south"></div><div class="small">Sur</div></div>
        </div>

        <div class="small">Instrucciones rápidas: usa 'Oscilar' para ver ondas periódicas; 'Manual' te permite arrastrar el imán con el ratón; 'Barrer' hace un recorrido único a través de la bobina.</div>
      </div>
    </div>
  </div>

<script>
// --- Parámetros físicos estilizados del modelo ---
const canvas = document.getElementById('scene');
const ctx = canvas.getContext('2d');
const plot = document.getElementById('plot');
const pctx = plot.getContext('2d');

let W = canvas.width, H = canvas.height;

// estado
let state = {
  N: 200,          // vueltas
  B0: 1.0,         // fuerza relativa del imán
  A: 10,           // cm^2 -> convert to m^2 later
  speed: 1.0,      // frecuencia/velocidad
  mode: 'osc',     // 'osc','manual','sweep'
  playing: true,
  t: 0,
  dt: 1/60,
  magnet: {x: 80, y: H/2, vx: 0, dragging: false},
  lastPhi: null,
  plotData: [],
}

// interfaz
const Nslider = document.getElementById('N');
const B0slider = document.getElementById('B0');
const speedSlider = document.getElementById('speed');
const Aslider = document.getElementById('A');
const modeSelect = document.getElementById('mode');
const playBtn = document.getElementById('play');
const pauseBtn = document.getElementById('pause');
const stepBtn = document.getElementById('step');
const resetBtn = document.getElementById('reset');

const Nval = document.getElementById('Nval');
const Bval = document.getElementById('Bval');
const speedVal = document.getElementById('speedVal');
const Aval = document.getElementById('Aval');
const modeLabel = document.getElementById('modeLabel');
const led = document.getElementById('led');
const voltageDisplay = document.getElementById('voltage');

// util: convert cm^2 to m^2
function cm2_to_m2(c){return c/10000}

// B(z) modelo (campana) centrada en la posición del imán
function B_field(z, magnetPos, B0){
  // z: position along x axis
  const sigma = 40; // ancho en pixeles
  const dx = z - magnetPos;
  return B0 * Math.exp(- (dx*dx)/(2*sigma*sigma));
}

// flujo Φ ≈ N * A * B(z)  (A en m^2, B en 'arb. units')
function flux(N, A_m2, Bz){
  // A_m2 scales the B to volts magnitude; include a scale factor
  const scale = 1.0;
  return N * A_m2 * Bz * scale;
}

// dibujar la escena
function draw(){
  ctx.clearRect(0,0,W,H);

  // bobina: rect with many turns drawn
  const coilX = 240, coilW = 220, coilY = 60, coilH = 160;
  ctx.save();
  // bobina exterior
  ctx.fillStyle = 'rgba(170,200,255,0.03)';
  roundRect(ctx, coilX-8, coilY-8, coilW+16, coilH+16, 10, true, false);

  // dibujar vueltas como líneas curvas
  ctx.strokeStyle = 'rgba(150,200,255,0.7)';
  ctx.lineWidth = 2;
  const turns = Math.min(80, Math.round(state.N/ (state.N>400?10: (state.N>100?2:1))));
  for(let i=0;i<turns;i++){
    const frac = i/turns;
    const x1 = coilX + frac*coilW;
    ctx.beginPath();
    ctx.ellipse(x1, coilY+coilH/2, 20, coilH/2 - 6, 0, Math.PI*0.9, Math.PI*2.1);
    ctx.stroke();
  }

  // axis
  ctx.restore();

  // imán (dos polos)
  const m = state.magnet;
  const magW = 36, magH = 54;
  // draw magnet body
  // north
  ctx.save();
  ctx.fillStyle = '#c33';
  roundRect(ctx, m.x - magW/2, m.y - magH/2, magW/2, magH, 6, true, false);
  ctx.fillStyle = '#2353c8';
  roundRect(ctx, m.x , m.y - magH/2, magW/2, magH, 6, true, false);
  ctx.restore();

  // center line
  ctx.beginPath(); ctx.setLineDash([4,6]); ctx.strokeStyle = 'rgba(200,220,255,0.12)'; ctx.moveTo(0,H/2); ctx.lineTo(W,H/2); ctx.stroke(); ctx.setLineDash([]);

  // labels
  ctx.fillStyle = '#a8cfff'; ctx.font = '13px sans-serif';
  ctx.fillText('Imán (N / S)', m.x - 36, m.y - magH/2 - 8);
  ctx.fillText('Bobina (N vueltas)', coilX + coilW/2 - 40, coilY - 12);

  // show B magnitude as translucent gradient behind coil
  for(let x=coilX; x<coilX+coilW; x+=3){
    const B = B_field(x, m.x, state.B0);
    const alpha = Math.min(0.9, B*0.9);
    ctx.fillStyle = `rgba(20,160,255,${alpha*0.12})`;
    ctx.fillRect(x, coilY, 3, coilH);
  }
}

function roundRect(ctx, x, y, w, h, r, fill, stroke) {
  if (typeof r === 'undefined') r = 5;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

// --- simulación física simplificada ---
let lastTime = null;
function step(now){
  if(!lastTime) lastTime = now;
  const elapsed = (now - lastTime) / 1000; // s
  lastTime = now;
  if(state.playing){
    // update time
    state.t += elapsed * state.speed;

    // update magnet depending on mode
    if(state.mode === 'osc'){
      // simple harmonic motion around center
      const center = 240; const amp = 160;
      state.magnet.x = center + amp * Math.sin(state.t*2*Math.PI*0.6);
    } else if(state.mode === 'sweep'){
      const start = 60, end = 620;
      const period = 2.6 / state.speed; // longer for slow
      const frac = ( (state.t % period) / period );
      state.magnet.x = start + frac*(end-start);
      // when reaches end, stop
      if(frac>0.999) state.playing = false;
    }
  }

  if(state.mode === 'manual' && state.magnet.dragging){ /* mouse handler sets x */ }

  // compute flux and induced voltage
  // sample positions along coil center to get B at coil
  const coilCenterX = 240 + 220/2;
  const Bz = B_field(coilCenterX, state.magnet.x, state.B0);
  const A_m2 = cm2_to_m2(state.A);
  const Phi = flux(state.N, A_m2, Bz);

  // numerical derivative: dPhi/dt
  let dPhi_dt = 0;
  if(state.lastPhi !== null){
    dPhi_dt = (Phi - state.lastPhi) / elapsed;
  }
  state.lastPhi = Phi;

  // induced voltage (arb. units -> treat as volts scaling)
  // V = - dPhi/dt (we included N in flux), so:
  const V = - dPhi_dt;

  // store for plot
  state.plotData.push({t: Date.now()/1000, V});
  if(state.plotData.length > 800) state.plotData.shift();

  // update UI
  voltageDisplay.textContent = V.toFixed(3) + ' V';
  // LED threshold
  const ledOn = Math.abs(V) > 0.15;
  led.classList.toggle('on', ledOn);

  // draw
  draw();
  drawPlot();

  if(state.playing || state.mode === 'manual') requestAnimationFrame(step);
}

function drawPlot(){
  // clear
  pctx.clearRect(0,0,plot.width,plot.height);
  // axes
  pctx.strokeStyle = 'rgba(200,220,255,0.15)';
  pctx.beginPath(); pctx.moveTo(30,10); pctx.lineTo(30,plot.height-20); pctx.lineTo(plot.width-6,plot.height-20); pctx.stroke();

  // sample V data for last 4 seconds
  const now = Date.now()/1000;
  const windowSec = 4.0;
  const data = state.plotData.filter(d => now - d.t <= windowSec);
  if(data.length<2) return;
  // normalize into canvas
  const maxV = Math.max(...data.map(d=>Math.abs(d.V)).concat([0.15]));
  const left = 32, right = plot.width-8, top=10, bottom=plot.height-20;

  pctx.beginPath();
  for(let i=0;i<data.length;i++){
    const x = left + ( (windowSec - (now - data[i].t)) / windowSec) * (right-left);
    const y = (top + bottom) /2 - (data[i].V / maxV) * ((bottom-top)/2);
    if(i===0) pctx.moveTo(x,y); else pctx.lineTo(x,y);
  }
  pctx.strokeStyle = 'rgba(80,200,255,0.95)'; pctx.lineWidth = 1.8; pctx.stroke();

  // center line
  pctx.strokeStyle = 'rgba(200,220,255,0.12)'; pctx.beginPath(); pctx.moveTo(left,(top+bottom)/2); pctx.lineTo(right,(top+bottom)/2); pctx.stroke();

  // labels
  pctx.fillStyle = '#bcd7ff'; pctx.font='12px sans-serif'; pctx.fillText('V(t) inducida (ventana ' + windowSec + ' s)', 36,12);
}

// --- eventos UI ---
Nslider.addEventListener('input', e=>{ state.N = +e.target.value; Nval.textContent = state.N; });
B0slider.addEventListener('input', e=>{ state.B0 = +e.target.value; Bval.textContent = state.B0; });
speedSlider.addEventListener('input', e=>{ state.speed = +e.target.value; speedVal.textContent = state.speed; });
Aslider.addEventListener('input', e=>{ state.A = +e.target.value; Aval.textContent = state.A; });
modeSelect.addEventListener('change', e=>{ state.mode = e.target.value; modeLabel.textContent = state.mode === 'osc' ? 'Oscilar' : (state.mode === 'manual' ? 'Manual' : 'Barrer'); });

playBtn.addEventListener('click', ()=>{ state.playing = true; lastTime = null; requestAnimationFrame(step); });
pauseBtn.addEventListener('click', ()=>{ state.playing = false; });
stepBtn.addEventListener('click', ()=>{ // advance a single frame
  lastTime = performance.now(); state.playing = true; setTimeout(()=>state.playing=false, 40); requestAnimationFrame(step);
});
resetBtn.addEventListener('click', ()=>{ state.t = 0; state.magnet.x = 80; state.plotData = []; state.lastPhi = null; state.playing = false; drawPlot(); draw(); });

// mouse drag for manual mode
canvas.addEventListener('mousedown', (e)=>{
  const r = canvas.getBoundingClientRect();
  const x = e.clientX - r.left;
  const y = e.clientY - r.top;
  const dx = x - state.magnet.x; const dy = y - state.magnet.y;
  if(Math.hypot(dx,dy) < 60){ state.magnet.dragging = true; state.mode = 'manual'; modeSelect.value='manual'; modeLabel.textContent='Manual'; }
});
window.addEventListener('mousemove',(e)=>{
  if(state.magnet.dragging){ const r = canvas.getBoundingClientRect(); state.magnet.x = Math.max(20, Math.min(W-20, e.clientX - r.left)); }
});
window.addEventListener('mouseup',()=>{ state.magnet.dragging = false; });

// resize handling
window.addEventListener('resize', ()=>{ /* noop for fixed size canvas */});

// init draw
draw(); drawPlot(); requestAnimationFrame(step);

</script>
</body>
</html>